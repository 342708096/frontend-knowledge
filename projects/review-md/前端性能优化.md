## 一、 网页生成的过程

![MacDown Screenshot](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091501.png)

网页生成过程, 大致分为5步

1. HTML代码转化成DOM
2. CSS代码转化成CSSOM（CSS Object Model）
3. 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
4. 生成布局（layout），即将所有渲染树的所有节点进行平面合成
5. 将布局绘制（paint）在屏幕上

这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。

"生成布局"（flow）和"绘制"（paint）这两步，合称为"渲染"（render）。

## 二、 网络请求优化
1. DNS缓存

	DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
	
2. DNS负载均衡

	DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡
	
3. cdn 负载均衡

	一个网页请求统一域名的外部资源连接数是有限的, 大概可以并发(2~3)个, 所以尽量把静态资源分散到不同的cdn上。
	
4. 跨域CORS优化

	cors规则约束了跨域请求, 特别是复杂请求会发生预检请求, 需要注意, 不过对静态资源没有影响

			

## 三、 静态资源优化

1. 合理放置脚本位置, css放置在head中, js放在body最后
2. 合理利用defer, async 属性来加载js, 这样不会阻塞渲染
3. 合理配置浏览器缓存meta标签, 设置尽量大一些的过期时间
4. 预加载

	`<link rel="prefetch" ></link>`
	这段代码告诉浏览器，这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低。也就是说prefetch通常用于加速下一次导航，而不是本次的。被标记为prefetch的资源，将会被浏览器在空闲时间加载。
	
	`<link rel="preload" ></link>`
	preload通常用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度。
	`import()`函数预取js文件
5. hybrid 技术, 本地file协议加载静态资源, 媲美原生
6. 	合并网络请求

	* webpack将js文件合理拆分打包, 将本页面需要的js打成一个包
	* css做雪碧图
	* 矢量图和字体图标
	* inline-img base64编码和css打包在一起

	
7. 	懒加载

	* 只加载用户当前视口内的图片, 随着用户滚动操作再异步加载更多, 来提高首屏渲染速度
	* 为了更好的用户体验, 会有一个缩略图, 或者占位图

8. 静态资源压缩

	* js  uglify rollup打包
	* css 压缩
	* 图片压缩
	* webp jpg png 矢量图	
	
	
	
## 四、 重绘重排优化	


提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。

尽量不要把读操作和写操作，放在一个语句里面。

```

// bad
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + "px";
div.style.top = top + 10 + "px";

```

### 一般的规则是:

* 样式表越简单，重排和重绘就越快。
* 重排和重绘的DOM元素层级越高，成本就越高。
* table元素的重排和重绘成本，要高于div元素


### 九个技巧

有一些技巧，可以降低浏览器重新渲染的频率和成本。

第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。

第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。

第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。

第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。

第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。

第八条，使用虚拟DOM的脚本库，比如React等。

第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。

### 帧动画的优化

大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。
所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。

如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。

### 总结
 1. dom操作读取分离, 尽量减少dom操作的次数
 2. 尽量使用离线DOM，而不是真实的网面DOM, 使用Fragment标签来避免一次插入大量dom元素
 3. dom引用要做缓存
 4. 尽量使用class 来配置css属性, 不要写内联样式
 5. 事件委托
 6. 虚拟DOM
 7. 动画优化, 开启硬件加速
 8. 使用window.requestAnimationFrame()
 9. 减少使用iframe
 10. 后端渲染SSR
 11. 减少DOM层级
 12. 局部重绘和重排(ajax, snabbdom)

 
## 代码优化
 
 1. 事件除颤
 2. 慎用with, 会延长作用域链
 3. 慎用闭包
 4. 避免使用eval和Function
 5. 字符串拼接避免使用'+', 应该使用array.join
 6. css选择符
 
